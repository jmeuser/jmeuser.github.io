<html><head>
 <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata">
 <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen">
</head>
<body><pre>
N is the intersection of math and computer science.
It is like a calculator for modern computation.
Just as the Babylonia, Egyptian, and Roman numerals were replaced by the efficiency of our modern Hindu-Arabic decimal system, so do past notations for computing and calculating give way to N.

N is natural.
Simple, straight forward, and interactive.
 


Being a product of my imagination, Iverson's J (and APL), and Whitney's k.

Points of focus are as follows:
Separate nouns from verbs i.e. keep data away from the actions performed on it.
clarity and exactness
unavoidable necessity
simplifying generality
idiomatic and mnemonic
n-dimensional
Similarities between subexpressions should be explicitly collected into a single subexpression e.g.

(3*x)+(3*y)+(3*z)
+/ 3* x,y,z

(x+1)*(x+2)*(x+3)
*/ x+ 1+!3

(x)+(x*(1+x))+(x*(1+x)*(2+x))+(x*(1+x)*(2+x)*(3+x))
+/ (*/ x+ !)" 1+ !4

1*2*3*4*5*6
*/ 1,2,3,4,5,6
*/1+! 6

x*(x+1)*(x+2)*(x+3)*(x+4)
*/ x,(x+1),(x+2),(x+3),x+4
*/ x+ !5
x */+ !5

(x+1)*(x+15)*(x+-23)
*/ x+ 1, 15, - 23

(1%t)*((2^t)%1+t)*((^t 1+ 1% 2)%1+t%2)*((^t 1+ 1% 3)%1+t%3)
*/ (1%t), (^t 1+ 1%)%(1+ t%) 1+ !3

Note */ (1%t), (^t 1+ 1%)%(1+ t%) 1+ !n is the n-th partial product of Euler's product expression for Gamma of t .

n choose k
(*/ n-)%(*/ 1+) !k
*/ (n-)%(1+) !k
*/n-%1+ !k

A method of computing the n-th Laguerre polynomial at x
+/ (*/ x^, (- 1)^, (n-%1+ !), 1% (*/1+!)) !1+n

Another method (though the same, just not explicit i.e. breaking into parts)
C:{*/x-%1+!y}   n C k means n choose k
f:*/1+!         f k means factorial of k
+/ (*/ x^, (- 1)^, (n C), 1% f) !1+n




N-dimensional statements are often simpler and clearer than their specific instances.
This is achieved using Iverson's adverb constructions.
Summation notation is replaced with +/ .
For example +/x+y*!z sums the first z terms of an arithmetic sequence.
It can be read from left to right as "plus over x plus y times enumerate z".
 
The unary verb ! is called enumerate.
It stores a rectangular array of consecutive numerals in row-major form.

 !0
()
 !10
0 1 2 3 4 5 6 7 8 9
 !3 3
0 1 2
3 4 5
6 7 8
 !3 3 3
 0  1  2
 3  4  5
 6  7  8

 9 10 11
12 13 14
15 16 17

18 19 20
21 22 23
24 25 26

Some may prefer to allocate !27 and store its shape somewhere else instead of using !3 3 3 .

"
Given a k-dimensional array with c-word elements A I"!k for (0&lt;|=I) &amp; I&lt;|=d (or &amp;/ &lt;|=2\ 0,I,d) we can store it in memory so that 
(A LOC I) = +/ (A LOC k#0), (*/ c, I, {1+ (1+x)_ d"!k})" 1+ !k
or
a:*/ c, {1+ (1+x)_ d !k}
(A LOC I) = +/ (A LOC k#0), a*I" 1+ !k
"From TAOCP V1E3 pg.299 (translated to N)

Notice, the math described here is also the code needed to implement such an allocation method.

The meaning of the expression +/x+y*!z has great generality.
Each term of the sum is made by applying x+y* to an item of !z .
The expression x+y* or x+ y* stands for an arithmetical sequence starting at x with step size y.
An arithmetic sequence starting at 2 with step size 3 named s would be defined by writing

 s:2+3*
 s 0
2
 s 1
5
 2+3* 2
8
 2+ 3* 2
8
 s.2
8
 s 0 1 2 3
2 5 8 11
 s.0 1 2 3
2 5 8 11
 s.!4
2 5 8 11
 s !4
2 5 8 11
 s!4
2 5 8 11
 s"!4
2 5 8 11
 s"1 !4
2 5 8 11

Often, there is more than one way to say the same thing.

In general if s takes a numeral and returns a term of a sequence (i.e. if s is a verb) then +/s!n sums over the first n terms of s .
s need not give a simple numeral.
It may produce a matrix or higher dimensional array.
Suppose s:2*,2+,2- which is read "a is two times append two plus append two minus" then

 s 3
6 5 0n1

That is s 3 (or s.3) gives the vector 6 5 0n1 whose first component is 6, second component is 5, and third component is negative one.
Then

 a:2*,2+,2-
 (+/a"!3)=(a 0)+(a 1)+a 2
1
 (+/a"!3)=(2*,2+,2- 0)+(2*,2+,2- 1)+2*,2+,2- 2
1
 (2*,2+,2- 0)=(2*0),(2+0),2-0
1
 (2*0),(2+0),2-0
0 2 2
 (2*1),(2+1),2-1
2 3 1
 (2*2),(2+2),2-2
4 4 0
 (+/a"!3)=+/0 2 2;2 3 1;4 4 0
1
 +/0 2 2;
   2 3 1;
   4 4 0
6 9 3
 +/a"!3
6 9 3

That example shows how one can explore the meaning of the notation and play with math and computer science.
It is a simple example, and many find it unfamiliar, preferring the classical summation notation.
The reason is that in these simple examples, that is in the classical uses of summation notation, N seems clumsy.
The strength of N is in the simplicity of statements that are otherwise hard to express using classical summation notation.

Knuth, Graham, and Patashnik's Concrete Mathematics is probably the most passionate love poem to summations.
In it they embrace Iverson's square bracket notation, but ignore his / adverb.
Let's start by considering why they worship classical summation notation.
First, they call it "generalized Sigma-notation" on pg.22 and contrast it with delimitated summation.
Their first significant evidence is the sum of the first 100 odd squares.
First they present the "generalized Sigma-notation" for the sum of the squares of the first 100 odd integers:
  ___
  \      2
  /__   k  
0&lt;k&lt;100
  k odd

This is contrasted with the delimited form:

 ___49
 \           2
 /__   (2k+1)
   k=0

The savings being that the idea "sum the squares of all odd integers below 100" is better communicated in the former than the latter.
The purpose is to focus our attention on the information that we're not just squaring any numbers, we're square odd numbers.
And not just any odd numbers, those odd numbers that are less than 100.
The argument is that (1+2*k)^2 is a "bad" way to represent the square of an odd number when manipulating it in a proof using English as its metalanguage.
(one might write it as {^2 1+ 2*}k )

My contention is that N provides a much simpler interface to these concepts (both on a chalk board, in a book, and yes... on a computer).
First, the savings in generalized Sigma-notation comes from its encoding of the information "odds less than 100" by placing constraints on k.
Those constraints being "0&lt;k&lt;100" {0&lt; &amp; &lt;100}k (read "zero less and less one hundred k") and "k odd".
I would write this sum using N as follows.
First let olt mean "odds less than".
You might write it casually as:

olt:   odds less than

where everything following "   " is a comment.
You would read the expression "olt:   odds less than" as "olt is (or stands for) odds less than"
That being the principle information we must communicate.
I would then write the sum +/ ^2" olt 100 which reads "plus over power two each olt one hundred".
Or, for someone familiar with this notation (just as you would have to be to use "generalized sigma notation") it reads
"sum of the squares of odds less than one hundred"
Notice, there is no extraneous variable "k" there is only the information on what actions are to be performed.
Now, the real difference between the generalized sigma notation and the delimitated form is how we represent odds less than one hundred.
This is left un identified in N as we've used it.
To review, the whole N statement would be

olt:   odds less than
+/ ^2" olt 100

where it is obvious we have yet to specify how olt is "constructed".
In CM they've chosen to represent odd numbers as the result of applying 1+2* to a numeral.
One might define odd:1+2* so that odd n gives the n-th odd number.
Though, this doesn't make it easy to know whether odd.23 is less than 100 or not.
We could find out easily by listing out the first 100 odd numbers and seeing where they are less than 100:

 &amp;(odd!100)&lt;100
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49

This, being very close to k code, is read "where odd of enumerate 100 less 100".
An someone used to this notation would say "where the first 100 odds are less than 100".
We could select the maximum number (49) with

&amp;/&amp;(odd!100)&lt;100

Which is read "meet over where odd of enumerate 100 less 100".
In this "pidgen" English you can instantly extract its meaning and means of computation.
So one could write the delimited form as

odd:1+2*
+/ ^2 odd &amp;/&amp;100&gt;odd!100

Or, more as is done in Concrete Math,

+/^2 1+2*!49

Which is just as unexpressive as the standard delimitated sigma notation for such an expression.

The binary operation - is likely to be replaced by monus when used on natural numerals (chars).
When applied to an integer quantity (ints), like 0n2, it becomes minus.
Arguments are automatically promoted to the meet of their respective types.

As an example of using - with natural numerals and integer numerals:

 0-3
0
 5-6
0
 6-5
1
 0n0-5
0n5
 5n6-5
0n6
 

The notation for numerals is best thought of the building of compound nouns (komposita) as in Deutsch. 

a b c  # ! 0  A B C
d ` e  1 2 3  D ' E
f g h  4 5 6  F G H
i j k  7 8 9  I J K  
l m n  + - *  L M N
  o    :   ;    O   
p q r  &lt; = &gt;  P Q R
s . t  | ~ &amp;  S , T
u v w  $ _ @  U V W
x y z  % ^ ?  X Y Z
{ ( [  / " \  ] ) }

  ! " # $ % &amp; ' ( ) * + , - . /
0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ?
@ A B C D E F G H I J K L M N O
P Q R S T U V W X Y Z [ \ ] ^ _
` a b c d e f g h i j k l m n o
p q r s t u v w x y z { | } ~

! remainder    enumerate
" rank
# take         shape
$
% quotient
&amp; meet         where
'
* times        signum
+ plus
, append
- m[oi]nus     negate(not?)
. of
/ over
: is
;
&lt; less
= equal
&gt; more
?
@
[
\ (pre,in)fix 
]
^
_ drop         floor
`
{ 
| join
}
~

Classical Compositions
(f g h y) and (f @ g @ h y) give (f (g (h y)))

f
|
g
|
h
|
y

(x f g h y) and (x f @ g @ h y) give (x f (g (h y)))

  f
 / \
x   g
    |
    h
    |
    y

(g h y) and (g @ h y) give (g (h y))

g
|
h
|
y

(x g h y) and (x g @ h y) give (x g (h y))

  g
 / \
x   h
    |
    y

(f0 f1 ... fn g h y) and (f0 @ f1 @ .. @ fn @ g @ h y) give (f0 (f1 ..(g (h y))..))

f0
|
f1
|
:
|
fn
|
g
|
h
|
y

(x f0 f1 .. fn g h y) and (x f0 @ .. @ fn @ g @ h y) give (x f0 (f1 ..(g (h y))..)

  f0
 / \
x   f1
    |
    :
    |
    fn
    |
    g
    |
    h
    |
    y

Forks
(f g h) is a fork of f`g`h
((f g h) y) gives ((f y) g (h y))

  g
 / \
f   h
|   |
y   y

(x (f g h) y) gives ((x f y) g (x h y))

    g
   / \
  f   h
 /|   |\
x y   x y

Claws
(g h) is a claw of g`h
((g h) y) gives (g (h y))

 g
 |
 h
 |
 y

(x (g h) y) gives (g (x h y))

  g
  |
  h
 / \
x   y

(f ]) and (f [) makes f monadic (on either the left or right argument)

Trains
(f0 f1 .. fn g h) is a train of f0`f1`..`fn`g`h
if n is even then the train (f0 f1 .. fn g h) is a fork of forks
if n is even ((f0 f1 .. fn g h) y) gives ((f0 y) f1 (..((fn y) g (h y))..))

f1
| \
f0 f3
|  | \
y  f2 f5
   |  | \
   y  f4 :
      |   \
      y    g
          / \
         fn  h
         |   |
         y   y

if n is even (x (f0 f1 .. fn g h) y) gives ((x f0 y) f1 (..((x fn y) g (x h y))..))

  f1
  | \
  f0 f3
 /|  | \
x y  f2 f5
    /|  | \
   x y  f4 :
       /|   \
      x y    g
            / \
           fn  h
          /|   |\
         x y   x y

if n is odd then the train (f0 f1 .. fn g h) is a claw of forks
if n is odd ((f0 f1 .. fn g h) y) gives (f0 ((f1 y) f2 (..((fn y) g (h y))..)))

f0
|
f2
| \
f1 f4
|  | \
y  f3 :
   |   \
   y    g
       / \
      fn  h
      |   |
      y   y

if n is odd "x(f0 f1 .. fn g h)y"gives "(f0 (x f1 (..((x fn y)g(x h y))..)))"

  f0
  |
  f2
  | \
  f1 f4
 /|  | \
x y  f3 :
    /|   \
   x y    g
         / \
        fn  h
       /|   |\
      x y   x y

Copyright John Meuser 2015
</pre></body></html>
