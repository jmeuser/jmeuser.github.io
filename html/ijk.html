<html><head>
 <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata">
 <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen">
</head>
<body><pre>
ijk is a notational language for math, science, and society
Being a product of my imagination, Iverson's J (and APL), and Whitney's k, the name ijk only seemed natural.

Points of focus are as follows:
clarity and exactness
unavoidable necessity
simplifying generality
idiomatic and mnemonic
n-dimensional

N-dimensional statements are often simpler and clearer than their specific instances.
This is achieved using Iverson's adverb constructions.
Summation notation is replaced with +/ .
For example +/x+y*!z sums the first z terms of an arithmetic sequence.
It can be read from left to right as "plus over x plus y times enumerate z".
 
The unary verb ! is called enumerate.
It stores an rectangular array of consecutive numerals in row-major form.

 !0
()
 !10
0 1 2 3 4 5 6 7 8 9
 !3 3
0 1 2
3 4 5
6 7 8
 !3 3 3
 0  1  2
 3  4  5
 6  7  8

 9 10 11
12 13 14
15 16 17

18 19 20
21 22 23
24 25 26

Some may prefer to allocate !27 and store its shape somewhere else instead of using !3 3 3 .

"
Given a k-dimensional array with c-word elements A I"!k for &lt;|=/0,I,d we can store it in memory so that 
(A LOC I) = +/ (A LOC k#0), (*/ c, I, {1+ (1+x)_ d"!k})" 1+ !k
or
a:*/ c, {1+ (1+x)_ d !k}
(A LOC I) = +/ (A LOC k#0), a*I" 1+ !k
"From TAOCP V1E3 pg.299 (translated to ijk)

The meaning of the expression +/x+y*!z has great generality.
Each term of the sum is made by applying x+y* to an item of !z .
The expression x+y* or x+ y* stands for an arithmetical sequence starting at x with step size y.
An arithmetic sequence starting at 2 with step size 3 named s would be defined by writing

 s:2+3*
 s 0
2
 s 1
5
 2+3* 2
8
 2+ 3* 2
8
 s.2
8
 s 0 1 2 3
2 5 8 11
 s.0 1 2 3
2 5 8 11
 s.!4
2 5 8 11
 s !4
2 5 8 11
 s!4
2 5 8 11
 s"!4
2 5 8 11
 s"1 !4
2 5 8 11

Often, there is more than one way to say the same thing.

In general if s takes a numeral and returns a term of a sequence (i.e. if s is a verb) then +/s!n sums over the first n terms of s .
s need not give a simple numeral.
It may produce a matrix or higher dimensional array.
Suppose s:2*,2+,2- which is read "a is two times append two plus append two minus" then

 s 3
6 5 0n1

That is s 3 (or s.3) gives the vector 6 5 0n1 whose first component is 6, second component is 5, and third component is negative one.
Then

 a:2*,2+,2-
 (+/a"!3)=(a 0)+(a 1)+a 2
1
 (+/a"!3)=(2*,2+,2- 0)+(2*,2+,2- 1)+2*,2+,2- 2
1
 (2*,2+,2- 0)=(2*0),(2+0),2-0
1
 (2*0),(2+0),2-0
0 2 2
 (2*1),(2+1),2-1
2 3 1
 (2*2),(2+2),2-2
4 4 0
 (+/a"!3)=+/0 2 2;2 3 1;4 4 0
1
 +/0 2 2;
   2 3 1;
   4 4 0
6 9 3
 +/a"!3
6 9 3

That example shows how one can explore the meaning of the notation and play with math and computer science.
It is a simple example, and many find it unfamiliar, preferring the classical summation notation.
The reason is that in these simple examples, that is in the classical uses of summation notation, ijk seems clumsy.
The strength of ijk is in the simplicity of statements that are otherwise hard to express using classical summation notation.

Knuth, Graham, and Patashnik's Concrete Mathematics is probably the most passionate love poem to summations.
In it they embrace Iverson's square bracket notation, but ignore his / adverb.
Let's start by considering why they worship classical summation notation.
First, they call it "generalized Sigma-notation" on pg.22 and contrast it with delimitated summation.
Their first significant evidence is the sum of the first 100 odd squares.
First they present the "generalized Sigma-notation" for the sum of the squares of the first 100 odd integers:
 ___
 \     2
 /__  k
0&lt;k&lt;100
 k odd

This is contrasted with the delimited form:

 ___49
 \           2
 /__   (2k+1)
   k=0

The savings being that the idea "sum the squares of all odd integers below 100" is better communicated in the former than the latter.
The purpose is to focus our attention on the information that we're not just squaring any numbers, we're square odd numbers.
And not just any odd numbers, those odd numbers that are less than 100.
The argument is that (1+2*k)^2 is a "bad" way to represent the square of an odd number when manipulating it in a proof using English as its metalanguage.

My contention is that ijk provides a much simpler interface to these concepts (both on a chalk board, in a book, and yes... on a computer).
First, the savings in generalized Sigma-notation comes from its encoding of the information "odds less than 100" by placing constraints on k.
Those constraints being "0&lt;k&lt;100" and "k odd".
I would write this sum using ijk as follows.
First let olt mean "odds less than".
You might write it casually as:
olt:   /odds less than
where everything following "   /" is a "comment".
You would read the expression "olt:   /odds less than" as "olt is (or stands for) odds less than"
That being the principle information we must communicate.
I would then write the sum +/^2 olt 100 which reads "plus over power two olt one hundred".
Or, for someone familiar with this notation (just as you would have to be to use "generalized sigma notation") it reads
"sum of the squares of odds less than one hundred"
Notice, there is no extraneous variable "k" there is only the information on what actions are to be performed.
Now, the real difference between the generalized sigma notation and the delimitated form is how we represent odds less than one hundred.
This is left un identified in ijk as we've used it.
To review, the whole ijk statement would be
 olt:  /odds less than
 +/^2 olt 100
where it is obvious we have yet to specify how olt is "constructed".
In CM they've chosen to represent odd numbers as the result of applying 1+2* to a numeral.
One might define odd:1+2* so that odd n gives the n-th odd number.
Though, this doesn't make it easy to know whether odd.23 is less than 100 or not.
We could find out easily by listing out the first 100 odd numbers and seeing where they are less than 100:
 &amp;(odd!100)&lt;100
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
This, being very close to k code, is read "where odd of enumerate 100 less 100".
An someone used to this notation would say "where the first 100 odds are less than 100".
We could automatically select the maximum number (49) with
 &amp;/&amp;(odd!100)&lt;100
Which is read "max over where odd of enumerate 100 less 100".
In this "pidgen" English you can almost immediately extract its meaning and means of computation.
So one could write the delimited form as
odd:1+2*
+/ ^2 odd &amp;/&amp;100&gt;odd!100
Or, more as is done in Concrete Math,
+/^2 1+2*!49
Which is just as unexpressive as the standard delimitated sigma notation for such an expression.

The binary operation - is likely to be replaced by monus when used on natural numerals (chars).
When applied to an integer quantity (ints), like 0n2, it becomes minus.
Arguments are automatically promoted to the meet of their respective types.



a b c  # ! 0  A B C
d ` e  1 2 3  D ' E
f g h  4 5 6  F G H
i j k  7 8 9  I J K  
l m n  + - *  L M N
  o    :   ;    O   
p q r  &lt; = &gt;  P Q R
s . t  | ~ &amp;  S , T
u v w  $ _ @  U V W
x y z  % ^ ?  X Y Z
{ ( [  / " \  ] ) }

  ! " # $ % &amp; ' ( ) * + , - . /
0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ?
@ A B C D E F G H I J K L M N O
P Q R S T U V W X Y Z [ \ ] ^ _
` a b c d e f g h i j k l m n o
p q r s t u v w x y z { | } ~


! residue    enumerate
" rank(adv)
# take       shape
$
% quotient
&amp; meet
'
* times      signum
+ plus
, append
- m[oi]nus   negate(not?)
. of
/ over
: is
;
&lt; less
= equals
&gt; more
?
@
[
\
]
^
_ drop       floor
`
{
| join
}
~
</pre></body></html>
