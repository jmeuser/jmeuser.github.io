<html><head>
 <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata">
 <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen">
</head>
<body><pre>
ijk is a notational language for math, science, and society
Being a product of my imagination, Iverson's J (and APL), and Whitney's k, the name ijk only seemed natural.

Though there may soon be an interactive implementation of ijk, it is, and always will be, a notational language rather than a programming language.
Thus its design is guided not simply by a desire to add inject math into a programming language, or to bring a programming language into mathematical notation.
Rather it is meant to be a universal language for discussing, describing, and DOING math and science.

Points of focus are as follows:
clarity and exactness
unavoidable necessity
simplifying generality
idiomatic and mnemonic
n-dimensional

N-dimensional statements should be simpler and easier to understand than any specific instance.

This is achieved using Iverson's adverbs.
Summation notation is replaced with +/ over the appropriate terms of the sequence.
For example to sum over the first n terms of an arithmetic series with initial term a and common difference d is +/a+d*!n which is read "plus over a plus d times enumerate n".
The foundation of most calculations is !n where n is some numeral or an array of numerals.
The meaning of the expression +/a+d*!n has great generality.
Each term of the sum is made by applying (a+d*) to each item of !n .
In general if a takes a numeral and returns a term of a sequence then +/a"!n sums over the first n terms of the sequence a.
a need not be a simple numeral, rather it may produce a matrix or higher dimensional array.
Suppose a:2*,2+,2- which is read "a is two times append two plus append two minus" then 
 a 3
6 5 0n1
That is a 3 (or a.3) gives the vector 6 5 0n1 whose first component is 6, second component is 5, and their component is negative one.
Then
a:2*,2+,2-
 (+/a"!3)=(a 0)+(a 1)+a 2
1
 (+/a"!3)=(2*,2+,2- 0)+(2*,2+,2- 1)+2*,2+,2- 2
1
 (2*,2+,2- 0)=(2*0),(2+0),2-0
1
 (2*0),(2+0),2-0
0 2 2
 (2*1),(2+1),2-1
2 3 1
 (2*2),(2+2),2-2
4 4 0
 (+/a"!3)=+/0 2 2;2 3 1;4 4 0
1
 +/0 2 2;
   2 3 1;
   4 4 0
6 9 3
 +/a"!3
6 9 3
That example shows how one can explore the meaning of the notation and play with math and computer science.
It is a simple example, and many find it unfamiliar, preferring the classical summation notation.
The reason is that in these simple examples, that is in the classical uses of summation notation, ijk seems clumsy.
The strength of ijk is in the simplicity of statements that are otherwise hard to express using classical summation notation.

Knuth, Graham, and Patashnik's Concrete Mathematics is probably the most passionate love poem to summations.
In it they embrace Iverson's square bracket notation, but ignore his / adverb.
Let's start by considering why they worship classical summation notation.
First, they call it "generalized Sigma-notation" on pg.22 and contrast it with delimitated summation.
Their first significant evidence is the sum of the first 100 odd squares.
First they present the "generalized Sigma-notation" for the sum of the squares of the first 100 odd integers:
 ___
 \     2
 /__  k
0&lt;k&lt;100
 k odd

This is contrasted with the delimited form:

 ___49
 \           2
 /__   (2k+1)
   k=0

The savings being that the idea "sum the squares of all odd integers below 100" is better communicated in the former than the latter.
The purpose is to focus our attention on the information that we're not just squaring any numbers, we're square odd numbers.
And not just any odd numbers, those odd numbers that are less than 100.
The argument is that (1+2*k)^2 is a "bad" way to represent the square of an odd number when manipulating it in a proof using English as its metalanguage.

My contention is that ijk provides a much simpler interface to these concepts (both on a chalk board, in a book, and yes... on a computer).
First, the savings in generalized Sigma-notation comes from its encoding of the information "odds less than 100" by placing constraints on k.
Those constraints being "0&lt;k&lt;100" and "k odd".
I would write this sum using ijk as follows.
First let olt mean "odds less than".
You might write it casually as:
olt:   /odds less than
where everything following "   /" is a "comment".
You would read the expression "olt:   /odds less than" as "olt is (or stands for) odds less than"
That being the principle information we must communicate.
I would then write the sum +/^2 olt 100 which reads "plus over power two olt one hundred".
Or, for someone familiar with this notation (just as you would have to be to use "generalized sigma notation") it reads
"sum of the squares of odds less than one hundred"
Notice, there is no extraneous variable "k" there is only the information on what actions are to be performed.
Now, the real difference between the generalized sigma notation and the delimitated form is how we represent odds less than one hundred.
This is left un identified in ijk as we've used it.
To review, the whole ijk statement would be
 olt:  /odds less than
 +/^2 olt 100
where it is obvious we have yet to specify how olt is "constructed".
In CM they've chosen to represent odd numbers as the result of applying 1+2* to a numeral.
One might define odd:1+2* so that odd n gives the n-th odd number.
Though, this doesn't make it easy to know whether odd.23 is less than 100 or not.
We could find out easily by listing out the first 100 odd numbers and seeing where they are less than 100:
 &amp;(odd!100)&lt;100
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
This, being very close to k code, is read "where odd of enumerate 100 less 100".
An someone used to this notation would say "where the first 100 odds are less than 100".
We could automatically select the maximum number (49) with
 &amp;/&amp;(odd!100)&lt;100
Which is read "max over where odd of enumerate 100 less 100".
In this "pidgen" English you can almost immediately extract its meaning and means of computation.
So one could write the delimited form as
odd:1+2*
+/ ^2 odd &amp;/&amp;100&gt;odd!100
Or, more as is done in Concrete Math,
+/^2 1+2*!49
Which is just as unexpressive as the standard delimitated sigma notation for such an expression.

a b c  # ! 0  A B C
d ` e  1 2 3  D ' E
f g h  4 5 6  F G H
i j k  7 8 9  I J K  
l m n  + - *  L M N
  o    :   ;    O   
p q r  &lt; = &gt;  P Q R
s . t  | ~ &amp;  S , T
u v w  $ _ @  U V W
x y z  % ^ ?  X Y Z
{ ( [  / " \  ] ) }

  ! " # $ % &amp; ' ( ) * + , - . /
0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ?
@ A B C D E F G H I J K L M N O
P Q R S T U V W X Y Z [ \ ] ^ _
` a b c d e f g h i j k l m n o
p q r s t u v w x y z { | } ~


! residue    enumerate
"
# take       shape
$
% 
&amp; meet
'
* times
+ plus
,
- minus(monus?)
.
/
:
;
&lt; less
= equals
&gt; more
?
@
[
\
]
^
_
`
{
| join
}
~
</pre></body></html>
