<html><head>
 <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata">
 <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen">
</head>
<body><pre>
Programming Errors

This is a list of errors that I've made while programming.
It is organize chronologically.

20150929T1039 Converging Substitutions in Strings
A hacker rank problem asked to replace all occurrences of ' &amp;&amp; ' with ' and ', and ' || ' with ' or '.
My first solution was as follows:

from re import sub
I=[input() for _ in range(int(input()))]
A=[sub(' &amp;&amp; ',' and ',x) for x in I]
A=[sub(' \|\| ',' or ',x) for x in A]
for x in A:
    print(x)

For most of the test-cases this code seemed to work perfectly.
For some it did not.
It became apparently that the problem was with the stages at which the substitutions occurred.
Here is the specific example input that revealed my error:

1
text &amp;&amp; &amp;&amp; text

With my incorrect algorithm the output is as follows:

text and &amp;&amp; text

Notice that the second occurrence of ' &amp;&amp; ' was not replaced with ' and '.
This is because it is only after the substitution of ' and ' for the left most occurrence of ' &amp;&amp; ' that the second substring ' &amp;&amp; ' was actually formed.
That is, it is not until AFTER the substitution sub(' &amp;&amp; ',' and ',x) had been performed on the input string that the second substring ' &amp;&amp; ' would occur.
Thus, rather than needing a single pass, I needed to perform a convergent iteration of substitutions until the collected lines were no longer changed by a substitution.
Though this operation is easily called upon in J or k (as it is obviously primitive) it was not so difficult to implement the relevant behavior in python as follows:

from re import sub
I=[input() for _ in range(int(input()))]
A=I
B=[]
while A!=B:
    B=A
    A=[sub(' &amp;&amp; ',' and ',x) for x in A]
    A=[sub(' \|\| ',' or ',x) for x in A]
for x in A:
    print(x)

Though, I do not prefer this solution, as it does not seem properly "clear" or "clean", I was not motivated enough to go beyond this functioning correction to my initial logical error.


20150928T1527 Sorted Strings instead of Integers
In a Hacker Rank problem I was asked to read in a table of data and then to sort by its values down the k-th column.
My first solution was

I=[input().split() for _ in range(int(input().split()[0]))]
k=int(input())
O=sorted(I,key=lambda x: x[k])
for x in O:
    print(*x)

Which sorted I correctly, but the atoms of I were strings rather than integers, so the ordering was for strings, where as the question was asking that the input be ordered after interpreting it as a table of integers.
The correction is to convert each entry in the input table into an integer as it is being read in so that the sorting will take place with regards to integers rather than strings.
I.e. rather than sorting alphabetically they will be sorted numerically.
Thus the final correct code is as follows:

I=[[int(x) for x in input().split()] for _ in range(int(input().split()[0]))]
k=int(input())
O=sorted(I,key=lambda x: x[k])
for x in O:
    print(*x)



20150928T1121 replace 'import datetime' with 'from datetime import datetime'
While solving a HackerRank problem on dates and times in different timezones I came across a large number of interesting errors.
The most significant error was in my thinking that time was no big problem because computers must be great at keeping track of time.
While computers are great at keeping track of local time (for the most part, as long as you compute in a temperature controlled environment) there is little else they do well.
The largest error in time is that our methods of recording it are driving by politics over reason.
Thus, as long as time is a political problem, there will always be money for the poor programmer that must deal with computing across timezones and political barriers.
It is my desire that Knuth write some time management algorithms so that we might discover a data structure whose form is unavoidably necessary when dealing with time, but that is only a hope.

My original code was as follows,

import datetime
I=[[datetime.strptime(input(),'%a %d %b %Y %H:%M:%S %z') for x in range(2)] for _ in range(int(input()))]
O=[(x[0]-x[1]).total_seconds() for x in I]
for x in O:
    print(int(x))

There are actually two errors in this code, though one is much easier to fix than the other.
The question asked to take in two strings representing a time having the following form:

Day dd Mon yyyy hh:mm:ss +xxxx

Below this descriptive string I was told that +xxxx recorded the timezone.
I later found out that it is actually a record of an offset from UTC which is, for now, a politically stable time throughout the world (as stable as any political thing can be).
I immediately Googled "Python 3.x time zones" and was bombarded with an endless stream of "oh god help us all" type posts.
I ignored them all and went straight to the Python documentation for 3.5 on datetime.
There it seemed that it was possible to deal with timezones in a semi-meaningful way.
The documentation told me that the .strptime() method was independent of the operating system or available C libraries so I chose to parse the string that way.
In the language described by Python for sending format information to .strptime() the date format used in the problem is given by this string

'%a %d %b %Y %H:%M:%S %z'

The %z part is the one that gave me the real trouble.
I thought that all I needed was to import datetime and use the method .strptime() on the inputs.
What I didn't understand was that datetime is both the name of a module and the name of a class in that module.
Furthermore, the module provides a .strptime() method that acts kind of like the .strptime() method of the class with the same name as that module.
One significant difference is that the module method doesn't deal with the timezone offset in the way that an object of the class does.
So over a two day period I struggled to understand if I was using the wrong module or not, when, the entire time, I was using the right module, but had been calling a module method rather than an object method.
Finally, the corrected code was as follows:

from datetime import datetime
I=[[datetime.strptime(input(),'%a %d %b %Y %H:%M:%S %z') for x in range(2)] for _ in range(int(input()))]
O=[x[0]-x[1].total_seconds() for x in I]
for x in O:
    print(int(x))

Though, there is still one error left.
This logical error is my having forgot that the absolute value of the difference between the given pairs of date times was needed not the signed difference.
So, thankfully, arithmetic with timedelta objects is mostly like that with normal numbers so all I needed to do is wrap the difference in an absolute value.

from datetime import datetime
I=[[datetime.strptime(input(),'%a %d %b %Y %H:%M:%S %z') for x in range(2)] for _ in range(int(input()))]
O=[abs(x[0]-x[1]).total_seconds() for x in I]
for x in O:
    print(int(x))

With that, I passed the tests, and realized I would never get back those two days of confusion ever again.
This is probably the best example of why you want to record errors you make while programming, because they tend to cross boundaries from logical to runtime and back again.



20150926T1405 Python: raw_input() from python 2.x became input() in python 3
I was solving a problem for my application to LaunchCode and was using an expression

[sorted([int(x) for x in input().split()]) for _ in range(int(input()))]

and couldn't understand why it was giving a weird syntax error (I was not able to capture the error, but I tried to recreate it on my personal computer)

&gt;&gt;&gt; input()
12 12
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1
    12 12
        ^
SyntaxError: unexpected EOF while parsing

Here you can see that input() was called from the command line and I gave it 12 12.
It then gives a syntax error.
I discovered, after some rapid Googling, that I had learned of input() as a Python 3.x command, and that in Python 2.x I should have used raw_input().
I'm still not certain what the "real" problem is because it is ultimately irrelevant.
I just need to know that input() in python 3.x means raw_input() in Python 2.x



20150923T1637 Python: List Items vs. List Slices
While solving the HackerRank problem "Set .discard(), .remove() &amp; .pop()" I got this error

IndexError: list index out of range

from this code

input()
s={int(x) for x in input().split()}
I=[input().split() for x in range(int(input()))]
for x in I: eval('s.'+x[0]+'('+','.join(x[1])+')')
print(sum(s))

The problem was that x[1] referred to the second element of x when it should have referred to a potentially empty list of the remaining elements of x i.e. x[1] should have been x[1:].
The correct code is below.

input()
s={int(x) for x in input().split()}
I=[input().split() for x in range(int(input()))]
for x in I: eval('s.'+x[0]+'('+','.join(x[1:])+')')
print(sum(s))


20150921T1539 Python: .sort() occurs "in place"
While solving the HackerRank problem Sets - Symmetric Difference I came across an interest error in my thinking about the the sort method of lists.

Here is the code that I thought would work to solve the problem (the final solution can be found at jmeuser.github.io/html/hr.html under Sets - Symmetric Difference).

z=list((x.union(y)).difference(x.intersection(y))).sort()

where x and y are sets that were derived from the input.
I thought this code would set z to be a sorted list.
What it returned to z was actually nothing.
Specifically it returned this type error when I tried to iterate over it

TypeError: 'NoneType' object is not iterable

Sorting occurs "in place" I guess and thus the correct code is as follows:

z=list((x.union(y)).difference(x.intersection(y)))
z.sort()

These two commands will make it so that z is now a list sorted in ascending order.
I must admit that I don't like these side effects: there must be some serious performance trade off for such terrible notation.



20150915T1337
This python code was meant to be a solution to a simple Hacker Rank problem.
It asked to produce a pyramid of numbers using only the given for-loop and basic arithmetic.
The output should have looked like the following pyramid given an input of 4:
1
22
333
4444
But, as you can see in the code below, I tried to use ^ as the exponential operator.
In python ** denotes the exponential or power operator.
Alternatively, one can use pow(a,b) to denote a**b.

Error Code:

for i in range(1,input()):
    print(i*(10^i-1)/9)

Corrected code:

for i in range(1,input()):
    print(i*(10**i-1)/9)
</pre></body></html>
